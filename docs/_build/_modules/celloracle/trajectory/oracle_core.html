

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>celloracle.trajectory.oracle_core &mdash; celloracle 0.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'0.1.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> celloracle
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Welcome to celloracleâ€™s documentation!</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license/index.html">License</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citation/index.html">Authors and citations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">celloracle</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>celloracle.trajectory.oracle_core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for celloracle.trajectory.oracle_core</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">..utility.hdf5_processing</span> <span class="k">import</span> <span class="n">dump_hdf5</span><span class="p">,</span> <span class="n">load_hdf5</span>

<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>

<span class="kn">from</span> <span class="nn">.sankey</span> <span class="k">import</span> <span class="n">sankey</span>
<span class="kn">from</span> <span class="nn">.markov_simulation</span> <span class="k">import</span> <span class="n">_walk</span>
<span class="kn">from</span> <span class="nn">.oracle_utility</span> <span class="k">import</span> <span class="p">(</span><span class="n">_adata_to_matrix</span><span class="p">,</span> <span class="n">_adata_to_df</span><span class="p">,</span>
                             <span class="n">_adata_to_color_dict</span><span class="p">,</span> <span class="n">_get_clustercolor_from_anndata</span><span class="p">,</span>
                             <span class="n">_numba_random_seed</span><span class="p">,</span> <span class="n">_linklist2dict</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.oracle_GRN</span> <span class="k">import</span> <span class="n">_do_simulation</span><span class="p">,</span> <span class="n">_getCoefMatrix</span>
<span class="kn">from</span> <span class="nn">.modified_VelocytoLoom_class</span> <span class="k">import</span> <span class="n">modified_VelocytoLoom</span>
<span class="kn">from</span> <span class="nn">..network_analysis.network_construction</span> <span class="k">import</span> <span class="n">get_links</span>



<span class="k">def</span> <span class="nf">load_oracle</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load oracle object saved as hdf5 file.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_path (str): File path to the hdf5 file.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">load_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span> <span class="n">obj_class</span><span class="o">=</span><span class="n">Oracle</span><span class="p">)</span>


<div class="viewcode-block" id="Oracle"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle">[docs]</a><span class="k">class</span> <span class="nc">Oracle</span><span class="p">(</span><span class="n">modified_VelocytoLoom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Oracle is the main class in CellOracle.</span>
<span class="sd">    Oracle object imports scRNA-seq data (anndata) and TF information to infer cluster-specific GRNs.</span>
<span class="sd">    It can predict future gene expression patterns and cell state transition after perturbations of TFs.</span>
<span class="sd">    Please see the paper of CellOracle for details.</span>

<span class="sd">    The code of the Oracle class was made of three components below.</span>

<span class="sd">    (1) Anndata:  Gene expression matrix and metadata in single-cell RNA-seq are stored in anndata object.</span>
<span class="sd">    Processed values, such as normalized counts and simulated values, are stored as layers of anndata.</span>
<span class="sd">    Metadata (i.e., Cluster info) are saved in anndata.obs. Refer to scanpy/anndata documentation for detail.</span>


<span class="sd">    (2) Net: Net is a custom class in celloracle.</span>
<span class="sd">    Net object process several data to infer GRN.</span>
<span class="sd">    See the documentation of Net class for detail.</span>

<span class="sd">    (3) VelycytoLoom: Calculation of transition probability and visualization of directed trajectory graph will be performed in the same way as velocytoloom.</span>
<span class="sd">    VelocytoLoom is class for the Velocyto, which is a python library for RNA-velocity analysis.</span>
<span class="sd">    In the celloracle, we use almost the same functions as velocytoloom for the visualization, but celloracle use simulated gene expression values instead of RNA-velocity data.</span>

<span class="sd">    Some CellOracle&#39;s methods were inspired by velocyto analysis and some codes were made by modifying VelocytoLoom class.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        adata (anndata): Imported anndata object</span>
<span class="sd">        cluster_column_name (str): The column name in adata.obs about cluster info</span>
<span class="sd">        embedding_name (str): The key name in adata.obsm about dimensional reduction cordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">############################</span>
    <span class="c1">### 0. utility functions ###</span>
    <span class="c1">############################</span>
<div class="viewcode-block" id="Oracle.copy"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deepcopy itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.to_hdf5"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.to_hdf5">[docs]</a>    <span class="k">def</span> <span class="nf">to_hdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save object as hdf5.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_path (str): file path to save file. Filename needs to end with &#39;.celloracle.oracle&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.celloracle.oracle&quot;</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filename needs to end with &#39;.celloracle.oracle&#39;&quot;</span><span class="p">)</span>

        <span class="n">compression_opts</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">dump_hdf5</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span>
                  <span class="n">data_compression</span><span class="o">=</span><span class="n">compression_opts</span><span class="p">,</span>  <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                  <span class="n">noarray_compression</span><span class="o">=</span><span class="n">compression_opts</span><span class="p">,</span> <span class="n">pickle_protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


    <span class="c1">###################################</span>
    <span class="c1">### 1. Methods for loading data ###</span>
    <span class="c1">###################################</span>

<div class="viewcode-block" id="Oracle.import_TF_data"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.import_TF_data">[docs]</a>    <span class="k">def</span> <span class="nf">import_TF_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TF_info_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TF_info_matrix_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TFdict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load data about potential-regulatory TFs.</span>
<span class="sd">        You can import either TF_info_matrix or TFdict.</span>
<span class="sd">        See the tutorial of celloracle or motif_analysis module for an example to make such files.</span>

<span class="sd">        Args:</span>
<span class="sd">            TF_info_matrix (pandas.DataFrame): TF_info_matrix.</span>

<span class="sd">            TF_info_matrix_path (str): File path for TF_info_matrix (pandas.DataFrame).</span>

<span class="sd">            TFdict (dictionary): Python dictionary of TF info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">TF_info_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">TF_info_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;peak_id&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;gene_short_name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">TF_info_matrix_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">TF_info_matrix_path</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;peak_id&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;gene_short_name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">TFdict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">=</span><span class="n">TFdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Oracle.updateTFinfo_dictionary"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.updateTFinfo_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">updateTFinfo_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TFdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update a TF dictionary.</span>
<span class="sd">        If a key in the new TF dictionary already existed in the old TF dictionary, old values will be replaced with a new one.</span>

<span class="sd">        Args:</span>
<span class="sd">            TFdict (dictionary): Python dictionary of TF info.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">TFdict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.addTFinfo_dictionary"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.addTFinfo_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">addTFinfo_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TFdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add new TF info to pre-existing TFdict.</span>
<span class="sd">        Values in the old TF dictionary will remain.</span>

<span class="sd">        Args:</span>
<span class="sd">            TFdict (dictionary): Python dictionary of TF info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">TFdict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">TFdict</span><span class="p">[</span><span class="n">tf</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">tf</span><span class="p">:</span> <span class="n">targets</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">tf</span><span class="p">:</span> <span class="n">TFdict</span><span class="p">[</span><span class="n">tf</span><span class="p">]})</span></div>

<div class="viewcode-block" id="Oracle.get_cluster_specific_TFdict_from_Links"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.get_cluster_specific_TFdict_from_Links">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_specific_TFdict_from_Links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links_object</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract TF and its target gene information from Links object.</span>
<span class="sd">        This function can be used to reconstruct GRNs based on pre-existing GRNs saved in Links object.</span>

<span class="sd">        Args:</span>
<span class="sd">            links_object (Links): Please see the explanation of Links class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links_object</span><span class="o">.</span><span class="n">filtered_links</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_linklist2dict</span><span class="p">(</span><span class="n">links_object</span><span class="o">.</span><span class="n">filtered_links</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>

<div class="viewcode-block" id="Oracle.import_anndata_as_raw_count"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.import_anndata_as_raw_count">[docs]</a>    <span class="k">def</span> <span class="nf">import_anndata_as_raw_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">cluster_column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embedding_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">transform</span><span class="o">=</span><span class="s2">&quot;natural_log&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load scRNA-seq data. scRNA-seq data should be prepared as an anndata.</span>
<span class="sd">        Preprocessing (cell and gene filtering, calculate DR and cluster, etc.) should be done before loading data.</span>
<span class="sd">        The method imports RAW GENE COUNTS because unscaled and uncentered gene expression data are required for the GRN inference and simulation.</span>
<span class="sd">        See tutorial notebook for the details about how to process scRNA-seq data.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata (anndata): anndata object that stores scRNA-seq data.</span>

<span class="sd">            cluster_column_name (str): the column name about cluster info in anndata.obs.</span>
<span class="sd">                Clustering data suppose to be in anndata.obs.</span>

<span class="sd">            embedding_name (str): the key name about a dimensional reduction in anndata.obsm.</span>
<span class="sd">                Dimensional reduction (or 2D trajectory graph) should be in anndata.obsm.</span>

<span class="sd">            transform (str): The method for log-transformation. Chose one from &quot;natural_log&quot; or &quot;log2&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gene expression matrix (adata.X) does not seems to be raw_count because it contains negavive values.&quot;</span><span class="p">)</span>

        <span class="c1"># store data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span> <span class="o">=</span> <span class="n">cluster_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_name</span> <span class="o">=</span> <span class="n">embedding_name</span>

        <span class="c1">#if hasattr(self.adata, &quot;raw&quot;):</span>
        <span class="c1">#    self.adata.X = self.adata.raw.X.copy()</span>

        <span class="c1"># store raw count data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;raw_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># log transformation</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log2&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;natural_log&quot;</span><span class="p">:</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;normalized_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># update color information</span>
        <span class="n">col_dict</span> <span class="o">=</span> <span class="n">_get_clustercolor_from_anndata</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span>
                                                  <span class="n">cluster_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">,</span>
                                                  <span class="n">return_as</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">col_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]])</span>

        <span class="c1"># variable gene detection for the QC of simulation</span>
        <span class="sd">&quot;&quot;&quot;N = adata.shape[1]</span>
<span class="sd">        if N &gt;= 3000:</span>
<span class="sd">            N = 3000</span>
<span class="sd">        n = int(N/3)-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_cv_vs_mean</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_var_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Oracle.import_anndata_as_normalized_count"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.import_anndata_as_normalized_count">[docs]</a>    <span class="k">def</span> <span class="nf">import_anndata_as_normalized_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">cluster_column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embedding_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load scRNA-seq data. scRNA-seq data should be prepared as an anndata.</span>
<span class="sd">        Preprocessing (cell and gene filtering, calculate DR and cluster, etc.) should be done before loading data.</span>
<span class="sd">        The method will import NORMALIZED and LOG TRANSFORMED but NOT SCALED and NOT CENTERED DATA.</span>
<span class="sd">        See the tutorial for the details for an example of how to process scRNA-seq data.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata (anndata): anndata object that store scRNA-seq data.</span>

<span class="sd">            cluster_column_name (str): the column name about cluster info in anndata.obs.</span>
<span class="sd">                Clustering data suppose to be in anndata.obs.</span>

<span class="sd">            embedding_name (str): the key name about a dimensional reduction in anndata.obsm.</span>
<span class="sd">                Dimensional reduction (or 2D trajectory graph) should be in anndata.obsm.</span>

<span class="sd">            transform (str): The method for log-transformation. Chose one from &quot;natural_log&quot; or &quot;log2&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gene expression matrix (adata.X) contains negavive values. Please use UNSCALED and UNCENTERED data.&quot;</span><span class="p">)</span>

        <span class="c1"># store data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span> <span class="o">=</span> <span class="n">cluster_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_name</span> <span class="o">=</span> <span class="n">embedding_name</span>

        <span class="c1"># store raw count data</span>
        <span class="c1">#self.adata.layers[&quot;raw_count&quot;] = adata.X.copy()</span>

        <span class="c1"># normalization and log transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;normalized_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># update color information</span>
        <span class="n">col_dict</span> <span class="o">=</span> <span class="n">_get_clustercolor_from_anndata</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span>
                                                  <span class="n">cluster_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">,</span>
                                                  <span class="n">return_as</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">col_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]])</span>

        <span class="c1"># variable gene detection for the QC of simulation</span>
        <span class="sd">&quot;&quot;&quot;N = adata.shape[1]</span>
<span class="sd">        if N &gt;= 3000:</span>
<span class="sd">            N = 3000</span>
<span class="sd">        n = int(N/3)-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_cv_vs_mean</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_var_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span> <span class="o">=</span> <span class="kc">None</span></div>



    <span class="c1">####################################</span>
    <span class="c1">### 2. Methods for GRN inference ###</span>
    <span class="c1">####################################</span>
<div class="viewcode-block" id="Oracle.fit_GRN_for_simulation"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.fit_GRN_for_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">fit_GRN_for_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GRN_unit</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_cluster_specific_TFdict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do GRN inference.</span>
<span class="sd">        Please see the paper of CellOracle for details.</span>

<span class="sd">        GRN can be constructed at an arbitrary cell group.</span>
<span class="sd">        If you want to infer cluster-specific GRN, please set [GRN_unit=&quot;cluster&quot;].</span>
<span class="sd">        GRN will be inferred for each cluster. You can select Cluster information when you import data (not when you run this method.).</span>

<span class="sd">        If you set [GRN_unit=&quot;whole&quot;], GRN will be made using all cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            GRN_unit (str): select &quot;cluster&quot; or &quot;whole&quot;</span>

<span class="sd">            alpha (float or int): the strength of regularization.</span>
<span class="sd">                If you set a lower value, the sensitivity increase, and you can detect a weak network connection, but it might get more noize.</span>
<span class="sd">                With a higher value of alpha may reduce the chance of overfitting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prepare data for GRN calculation</span>
        <span class="n">gem_imputed</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;imputed_count&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulation_input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;imputed_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_for_trajectory_GRN</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="k">if</span> <span class="n">use_cluster_specific_TFdict</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">cluster_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;calculating GRN using cluster specicif TF dict...&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;calculating GRN in </span><span class="si">{cluster}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">cells_in_the_cluster_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_info</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>
                <span class="n">gem_</span> <span class="o">=</span> <span class="n">gem_imputed</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">_getCoefMatrix</span><span class="p">(</span><span class="n">gem</span><span class="o">=</span><span class="n">gem_</span><span class="p">,</span>
                                                                       <span class="n">TFdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span><span class="p">[</span><span class="n">cluster</span><span class="p">],</span>
                                                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;whole&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix</span> <span class="o">=</span> <span class="n">_getCoefMatrix</span><span class="p">(</span><span class="n">gem</span><span class="o">=</span><span class="n">gem_imputed</span><span class="p">,</span> <span class="n">TFdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">cluster_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;calculating GRN in </span><span class="si">{cluster}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">cells_in_the_cluster_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_info</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>
                    <span class="n">gem_</span> <span class="o">=</span> <span class="n">gem_imputed</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">_getCoefMatrix</span><span class="p">(</span><span class="n">gem</span><span class="o">=</span><span class="n">gem_</span><span class="p">,</span>
                                                                           <span class="n">TFdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="p">,</span>
                                                                           <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span></div>



    <span class="c1">#######################################################</span>
    <span class="c1">### 3. Methods for simulation of signal propagation ###</span>
    <span class="c1">#######################################################</span>

<div class="viewcode-block" id="Oracle.simulate_shift"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.simulate_shift">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perturb_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">GRN_unit</span><span class="o">=</span><span class="s2">&quot;whole&quot;</span><span class="p">,</span>
                       <span class="n">n_propagation</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ignore_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate signal propagation with GRNs. Please see the paper of CellOracle for details.</span>
<span class="sd">        This function simulates a gene expression pattern in the near future.</span>
<span class="sd">        Simulated values will be stored in anndata.layers: [&quot;simulated_count&quot;]</span>


<span class="sd">        Three data below are used for the simulation.</span>
<span class="sd">        (1) GRN inference results (coef_matrix).</span>
<span class="sd">        (2) perturb_condition: You can set arbitrary perturbation condition.</span>
<span class="sd">        (3) gene expression matrix: simulation starts from imputed gene expression data.</span>

<span class="sd">        Args:</span>
<span class="sd">            perturb_condition (dictionary): condition for perturbation.</span>
<span class="sd">               if you want to simulate knockout for GeneX, please set [perturb_condition={&quot;GeneX&quot;: 0.0}]</span>
<span class="sd">               Although you can set any non-negative values for the gene condition, avoid setting biologically unfeasible values for the perturb condition.</span>
<span class="sd">               It is strongly recommended to check actual gene expression values in your data before selecting perturb condition.</span>

<span class="sd">            n_propagation (int): Calculation will be performed iteratively to simulate signal propagation in GRN.</span>
<span class="sd">                you can set the number of steps for this calculation.</span>
<span class="sd">                With a higher number, the results may recapitulate signal propagation for many genes.</span>
<span class="sd">                However, a higher number of propagation may cause more error/noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 0. Reset previous simulation results if it exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1"># 1. prepare perturb information</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">perturb_condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perturb_condition</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_var_genes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ignore_warning</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Variability score of Gene </span><span class="si">{i}</span><span class="s2"> is too low. Simulation accuracy may be poor with this gene.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Variability score of Gene </span><span class="si">{i}</span><span class="s2"> is too low. Cannot perform simulation.&quot;</span><span class="p">)</span>

            <span class="c1"># reset simulation initiation point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulation_input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;imputed_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">simulation_input</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;simulation_input&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perturb_condition</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">simulation_input</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{i}</span><span class="s2"> is not in the data&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">simulation_input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perturb_condition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">simulation_input</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;simulation_input&quot;</span><span class="p">)</span>

        <span class="c1"># 2. load gene expression matrix (initiation information for the simulation)</span>
        <span class="n">gem_imputed</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;imputed_count&quot;</span><span class="p">)</span>

        <span class="c1"># 3. do simulation for signal propagation within GRNs</span>
        <span class="k">if</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;whole&quot;</span><span class="p">:</span>
            <span class="n">gem_simulated</span> <span class="o">=</span> <span class="n">_do_simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix</span><span class="p">,</span>
                                           <span class="n">simulation_input</span><span class="p">,</span>
                                           <span class="n">gem_imputed</span><span class="p">,</span>
                                           <span class="n">n_propagation</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="n">simulated</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cluster_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">):</span>
                <span class="n">cells_in_the_cluster_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_info</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>

                <span class="n">simulation_input_</span> <span class="o">=</span> <span class="n">simulation_input</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>
                <span class="n">gem_</span> <span class="o">=</span> <span class="n">gem_imputed</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>

                <span class="n">simulated_in_the_cluster</span> <span class="o">=</span> <span class="n">_do_simulation</span><span class="p">(</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span><span class="p">[</span><span class="n">cluster</span><span class="p">],</span>
                                             <span class="n">simulation_input_</span><span class="p">,</span>
                                             <span class="n">gem_</span><span class="p">,</span>
                                             <span class="n">n_propagation</span><span class="p">)</span>
                <span class="n">simulated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simulated_in_the_cluster</span><span class="p">)</span>
            <span class="n">gem_simulated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">simulated</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gem_simulated</span> <span class="o">=</span> <span class="n">gem_simulated</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">gem_imputed</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;GRN_unit shold be either of &#39;whole&#39; or &#39;cluster&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># 4. store simulation results</span>
        <span class="c1">#  simulated future gene expression matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulated_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gem_simulated</span><span class="o">.</span><span class="n">values</span>

        <span class="c1">#  difference between simulated values and original values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;delta_X&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulated_count&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;imputed_count&quot;</span><span class="p">]</span></div>


    <span class="c1">########################################</span>
    <span class="c1">### 4. Methods for Markov simulation ###</span>
    <span class="c1">########################################</span>
<div class="viewcode-block" id="Oracle.prepare_markov_simulation"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.prepare_markov_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_markov_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pick up cells for Markov simulation.</span>

<span class="sd">        Args:</span>
<span class="sd">            verbose (bool): If True, it plots selected cells.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sample uniformly the points to avoid density driven effects - Should reimplement as a method</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span>
        <span class="n">grs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">])</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">gr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">steps</span><span class="p">[</span><span class="n">dim_i</span><span class="p">])</span>
            <span class="n">grs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>

        <span class="n">meshes_tuple</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grs</span><span class="p">)</span>
        <span class="n">gridpoints_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">meshes_tuple</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">()</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ixs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">gridpoints_coordinates</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">diag_step_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">diag_step_dist</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">ixs</span> <span class="o">=</span> <span class="n">ixs</span><span class="p">[</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">]</span>
        <span class="n">gridpoints_coordinates</span> <span class="o">=</span> <span class="n">gridpoints_coordinates</span><span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span><span class="o">&lt;</span><span class="n">min_dist</span><span class="p">,:]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">]</span>

        <span class="n">ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ixs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span> <span class="o">=</span> <span class="n">ixs</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ixs</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ixs</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">[</span><span class="n">ixs</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                        <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;0.4&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_markov</span><span class="p">(</span><span class="n">sigma_D</span><span class="o">=</span><span class="n">diag_step_dist</span><span class="p">,</span> <span class="n">sigma_W</span><span class="o">=</span><span class="n">diag_step_dist</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
                       <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">cells_ixs</span><span class="o">=</span><span class="n">ixs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Oracle.run_markov_chain_simulation"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.run_markov_chain_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">run_markov_chain_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">n_duplication</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do Markov simlation to predict cell transition after perturbation.</span>
<span class="sd">        The transition probability between cells has been calculated</span>
<span class="sd">        based on simulated gene expression values in the signal propagation process.</span>
<span class="sd">        The cell state transition will be simulated based on the probability.</span>
<span class="sd">        You can simulate the process for multiple times to get a robust outcome.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_steps (int): steps for Markov simulation. This value is equivalent to the time after perturbation.</span>

<span class="sd">            n_duplication (int): the number for multiple calculations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">_numba_random_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_markov_simulation</span><span class="p">()</span>

        <span class="n">transition_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="n">transition_prob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">start_cell_id_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_cells</span><span class="p">),</span> <span class="n">n_duplication</span><span class="p">)</span>

        <span class="n">transition</span> <span class="o">=</span> <span class="n">_walk</span><span class="p">(</span><span class="n">start_cell_id_array</span><span class="p">,</span> <span class="n">transition_prob</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">)</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span><span class="p">[</span><span class="n">transition</span><span class="p">]</span>

        <span class="n">li</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span><span class="p">,</span> <span class="n">n_duplication</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.summarize_mc_results_by_cluster"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.summarize_mc_results_by_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">summarize_mc_results_by_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_use</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function summarizes the simulated cell state-transition by groping the results into each cluster.</span>
<span class="sd">        It returns sumarized results as a pandas.DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_use (str): cluster information name in anndata.obs.</span>
<span class="sd">               You can use any arbitrary cluster information in anndata.obs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mcmc_transition_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_use</span><span class="p">])[</span><span class="n">transition</span><span class="p">]</span>
        <span class="n">mcmc_transition_cluster</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mcmc_transition_cluster</span><span class="p">,</span>
                                               <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mcmc_transition_cluster</span></div>


<div class="viewcode-block" id="Oracle.plot_mc_resutls_as_sankey"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.plot_mc_resutls_as_sankey">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mc_resutls_as_sankey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_use</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the simulated cell state-transition as a Sankey-diagram after groping by the cluster.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_use (str): cluster information name in anndata.obs.</span>
<span class="sd">               You can use any arbitrary cluster information in anndata.obs.</span>

<span class="sd">            start (int): The starting point of Sankey-diagram. Please select a  step in the Markov simulation.</span>

<span class="sd">            end (int): The end point of Sankey-diagram. Please select a  step in the Markov simulation.</span>
<span class="sd">                if you set [end=-1], the final step of Markov simulation will be used.</span>

<span class="sd">            order (list of str): The order of cluster name in sankey-diagram.</span>

<span class="sd">            font_size (int): Font size for cluster name label in Sankey diagram.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mcmc_transition_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_mc_results_by_cluster</span><span class="p">(</span><span class="n">cluster_use</span><span class="p">)</span>
        <span class="n">mcmc_color_dict</span> <span class="o">=</span>  <span class="n">_adata_to_color_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_use</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">mcmc_transition_cluster</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]]</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order_</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">order_</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">order_left</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order_</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">unique</span><span class="p">()]</span>
            <span class="n">order_right</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order_</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">unique</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order_left</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="n">order_right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

        <span class="n">sankey</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">],</span>
               <span class="n">aspect</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span>
               <span class="n">colorDict</span><span class="o">=</span><span class="n">mcmc_color_dict</span><span class="p">,</span>
               <span class="n">leftLabels</span><span class="o">=</span><span class="n">order_left</span><span class="p">,</span> <span class="n">rightLabels</span><span class="o">=</span><span class="n">order_right</span><span class="p">)</span></div>


<div class="viewcode-block" id="Oracle.plot_mc_result_as_kde"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.plot_mc_result_as_kde">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mc_result_as_kde</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_time</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pick up one timepoint in the cell state-transition simulation and plot as a kde plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_time (int): the number in Markov simulation</span>

<span class="sd">            args (dictionary): An argument for seaborn.kdeplot.</span>
<span class="sd">                See seaborn documentation for detail (https://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">n_time</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.plot_mc_result_as_trajectory"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.plot_mc_result_as_trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mc_result_as_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_name</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pick up several timepoints in the cell state-transition simulation and plot as a line plot.</span>
<span class="sd">        This function can be used to visualize how cell-state changes after perturbation focusing on a specific cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            cell_name (str): cell name. chose from adata.obs.index</span>

<span class="sd">            time_range (list of int): the number in markov simulation</span>

<span class="sd">            args (dictionary): dictionary for the arguments for matplotlib.pyplit.plot.</span>
<span class="sd">                See matplotlib documentation for detail (https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">cell_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cell_ix_in_mcmctid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">cell_ix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># plot all cells in gray color</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cell_ix_in_mcmctid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_one_trajectory</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="c1"># plot cell of interest (initiation point of simulation) in red color</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_plot_one_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ix_in_mcmctid</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cell_ix_in_mcmctid</span><span class="p">,:]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">time_range</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">tt</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">tt</span><span class="p">],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>


    <span class="c1">###################################################</span>
    <span class="c1">### 5. GRN inference for Network score analysis ###</span>
    <span class="c1">###################################################</span>
<div class="viewcode-block" id="Oracle.get_links"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.get_links">[docs]</a>    <span class="k">def</span> <span class="nf">get_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_name_for_GRN_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bagging_number</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">test_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make GRN for each cluster and returns results as a Links object.</span>
<span class="sd">        Several preprocessing should be done before using this function.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_name_for_GRN_unit (str): Cluster name for GRN calculation. The cluster information should be stored in Oracle.adata.obs.</span>

<span class="sd">            alpha (float or int): the strength of regularization.</span>
<span class="sd">                If you set a lower value, the sensitivity increase, and you can detect a weak network connection, but it might get more noize.</span>
<span class="sd">                With a higher value of alpha may reduce the chance of overfitting.</span>

<span class="sd">            bagging_number (int): The number for bagging calculation.</span>


<span class="sd">            verbose_level (int): if [verbose_level&gt;1], most detailed progress information will be shown.</span>
<span class="sd">                if [verbose_level &gt; 0], one progress bar will be shown.</span>
<span class="sd">                if [verbose_level == 0], no progress bar will be shown.</span>

<span class="sd">            test_mode (bool): If test_mode is True, GRN calculation will be done for only one cluster rather than all clusters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">get_links</span><span class="p">(</span><span class="n">oracle_object</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">cluster_name_for_GRN_unit</span><span class="o">=</span><span class="n">cluster_name_for_GRN_unit</span><span class="p">,</span>
                          <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">bagging_number</span><span class="o">=</span><span class="n">bagging_number</span><span class="p">,</span>
                          <span class="n">verbose_level</span><span class="o">=</span><span class="n">verbose_level</span><span class="p">,</span> <span class="n">test_mode</span><span class="o">=</span><span class="n">test_mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">links</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Samantha Morris Lab

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>